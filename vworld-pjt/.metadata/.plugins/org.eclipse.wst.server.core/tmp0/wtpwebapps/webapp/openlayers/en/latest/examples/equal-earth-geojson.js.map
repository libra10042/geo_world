{"version":3,"file":"equal-earth-geojson.js","mappings":"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","sources":["webpack:///./equal-earth-geojson.js"],"sourcesContent":["import proj4 from 'proj4';\nimport Map from '../src/ol/Map.js';\nimport View from '../src/ol/View.js';\nimport GeoJSON from '../src/ol/format/GeoJSON.js';\nimport VectorLayer from '../src/ol/layer/Vector.js';\nimport {register} from '../src/ol/proj/proj4.js';\nimport {fromLonLat, get as getProjection, toLonLat} from '../src/ol/proj.js';\nimport RenderFeature from '../src/ol/render/Feature.js';\nimport VectorSource from '../src/ol/source/Vector.js';\n\n// Equal Earth projection with dynamic center meridian\nfunction dynEqualEarth(center, round = 15) {\n  const lon0 = Math.round(center[0] / round) * round;\n  const code = `EqualEarth${lon0}`;\n  let prj = getProjection(code);\n  if (!prj) {\n    proj4.defs(\n      code,\n      `+proj=eqearth +lon_0=${lon0} +x_0=0 +y_0=0 +R=6371008.7714 +units=m +no_defs +type=crs`,\n    );\n    register(proj4);\n    prj = getProjection(code);\n    prj.setGlobal(true);\n    prj.setExtent([-17243959.06, -8392927.6, 17243959.06, 8392927.6]);\n    prj.setWorldExtent([-180, -90, 180, 90]);\n  }\n\n  return prj;\n}\n\nconst initialCenter = [11, 0];\nconst initialProjection = dynEqualEarth(initialCenter, 1);\n\n(async () => {\n  const response = await fetch(\n    'https://openlayers.org/data/vector/ecoregions.json',\n    // 'https://openlayersbook.github.io/openlayers_book_samples/assets/data/countries.geojson',\n  );\n  const geojson = await response.json();\n\n  function jsonSource(geojson, projection) {\n    return new VectorSource({\n      features: new GeoJSON({\n        featureProjection: projection,\n        featureClass: RenderFeature,\n      }).readFeatures(geojson),\n      overlaps: false,\n    });\n  }\n\n  const vectorLayer = new VectorLayer({\n    source: jsonSource(\n      clipPolygon(geojson, initialCenter[0]),\n      initialProjection,\n    ),\n    extent: initialProjection.getExtent(),\n    wrapX: false,\n    style: {\n      'fill-color': ['string', ['get', 'COLOR'], '#eee'],\n    },\n  });\n\n  const map = new Map({\n    layers: [vectorLayer],\n    target: 'map',\n    view: new View({\n      projection: initialProjection,\n      center: initialCenter,\n      zoom: 0,\n      showFullExtent: true,\n    }),\n  });\n\n  // Event handler for updating view projection\n  function handleCenterChange() {\n    const degStep = 5;\n    const curView = map.getView();\n    const center = toLonLat(curView.getCenter(), curView.getProjection());\n    const newProjection = dynEqualEarth(center, degStep);\n    if (curView.getProjection().getCode() !== newProjection.getCode()) {\n      curView.un('change:center', handleCenterChange);\n      const lon0 = Math.round(center[0] / degStep) * degStep;\n      // Clip polygons at the new antimeridian to avoid rendering artifacts\n      const clippedJson = clipPolygon(geojson, lon0);\n      // Reload source to apply the new projection\n      vectorLayer.setSource(jsonSource(clippedJson, newProjection));\n      map.setView(\n        new View({\n          projection: newProjection,\n          center: fromLonLat(center, newProjection),\n          zoom: curView.getZoom(),\n          rotation: curView.getRotation(),\n          showFullExtent: true,\n        }),\n      );\n      map.getView().on('change:center', handleCenterChange);\n    }\n  }\n\n  map.getView().on('change:center', handleCenterChange);\n\n  function clipPolygon(geojson, lon0) {\n    function roundN(num, n = 10) {\n      return Math.round(num * Math.pow(10, n)) / Math.pow(10, n);\n    }\n    const minX = lon0 - 180.0;\n    const maxX = lon0 + 180.0;\n    const clippedJson = {type: 'FeatureCollection', features: []};\n    for (const feature of geojson.features) {\n      const depth = feature.geometry.type === 'MultiPolygon' ? 2 : 1;\n      const [featMinX, featMaxX] = feature.geometry.coordinates\n        .flat(depth)\n        .reduce(\n          (minmax, coord) => [\n            Math.min(minmax[0], coord[0]),\n            Math.max(minmax[1], coord[0]),\n          ],\n          [Number.MAX_VALUE, Number.MIN_VALUE],\n        );\n      const eps = 0.01;\n      if (\n        (featMinX < minX + eps && featMaxX > minX - eps) ||\n        (featMinX < maxX + eps && featMaxX > maxX - eps)\n      ) {\n        const offset = featMinX < minX ? 360 : -360;\n        const feat = structuredClone(feature);\n        if (feat.geometry.type === 'Polygon') {\n          feat.geometry.type = 'MultiPolygon';\n          feat.geometry.coordinates = [feat.geometry.coordinates];\n        }\n\n        const polys = [];\n        for (const polygon of feat.geometry.coordinates) {\n          const tpoly = structuredClone(polygon);\n          const ncoords = polygon.reduce((sum, ring) => sum + ring.length, 0);\n          let clamped = 0;\n          for (const ring of polygon) {\n            for (const coord of ring) {\n              const x = coord[0];\n              coord[0] = roundN(Math.min(Math.max(x, minX), maxX));\n              if (coord[0] !== roundN(x)) {\n                clamped++;\n              }\n            }\n          }\n          // Skip possibly degenerated polys with all coords clamped\n          if (clamped < ncoords) {\n            polys.push(polygon);\n          }\n          // Shift poly by 360° and clamp other part\n          if (clamped) {\n            let around180 = false;\n            for (const ring of tpoly) {\n              for (const coord of ring) {\n                const x = coord[0] + offset;\n                coord[0] = Math.min(Math.max(x, minX + eps), maxX - eps);\n                // this still creates bad polys when coords are around 180°\n                if (Math.abs(coord[0]) - 180 < 0.00000001) {\n                  around180 = true;\n                }\n              }\n            }\n            if (!around180) {\n              polys.push(tpoly);\n            }\n          }\n        }\n        feat.geometry.coordinates = polys;\n        clippedJson.features.push(feat);\n      } else {\n        clippedJson.features.push(feature);\n      }\n    }\n    return clippedJson;\n  }\n\n  const featureOverlay = new VectorLayer({\n    source: new VectorSource(),\n    map: map,\n    style: {\n      'stroke-color': 'rgba(255, 255, 255, 0.7)',\n      'stroke-width': 2,\n    },\n  });\n\n  let highlight;\n  const displayFeatureInfo = function (pixel) {\n    const feature = map.forEachFeatureAtPixel(pixel, function (feature) {\n      return feature;\n    });\n\n    const info = document.getElementById('info');\n    if (feature) {\n      info.innerHTML =\n        feature.get('ECO_NAME') || feature.get('name') || '&nbsp;';\n    } else {\n      info.innerHTML = '&nbsp;';\n    }\n\n    if (feature !== highlight) {\n      if (highlight) {\n        featureOverlay.getSource().removeFeature(highlight);\n      }\n      if (feature) {\n        featureOverlay.getSource().addFeature(feature);\n      }\n      highlight = feature;\n    }\n  };\n\n  map.on('pointermove', function (evt) {\n    if (evt.dragging) {\n      return;\n    }\n    displayFeatureInfo(evt.pixel);\n  });\n\n  map.on('click', function (evt) {\n    displayFeatureInfo(evt.pixel);\n  });\n})();\n"],"names":["dynEqualEarth","center","round","lon0","Math","code","prj","defs","setGlobal","setExtent","setWorldExtent","initialCenter","initialProjection","response","fetch","geojson","json","jsonSource","projection","features","featureProjection","featureClass","readFeatures","overlaps","vectorLayer","source","clipPolygon","extent","getExtent","wrapX","style","map","layers","target","view","zoom","showFullExtent","roundN","num","n","pow","minX","maxX","clippedJson","type","feature","depth","geometry","featMinX","featMaxX","coordinates","flat","reduce","minmax","coord","min","max","Number","MAX_VALUE","MIN_VALUE","eps","offset","feat","structuredClone","polys","polygon","tpoly","ncoords","sum","ring","length","clamped","x","push","around180","abs","getView","on","handleCenterChange","curView","getCenter","getProjection","newProjection","getCode","un","setSource","setView","getZoom","rotation","getRotation","featureOverlay","highlight","displayFeatureInfo","pixel","forEachFeatureAtPixel","info","document","getElementById","innerHTML","get","getSource","removeFeature","addFeature","evt","dragging"],"sourceRoot":""}